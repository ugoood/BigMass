
<!-- toc orderedList:0 depthFrom:1 depthTo:6 -->

* [day02, 03](#day02-03)
  * [1. xml语言和作用](#1-xml语言和作用)
  * [2. xml语法详解](#2-xml语法详解)
    * [2.1 xml 语法声明](#21-xml-语法声明)
      * [2.1.1 encoding 属性](#211-encoding-属性)
      * [2.1.2 standalone 属性](#212-standalone-属性)
    * [2.2 xml 元素(Element)](#22-xml-元素element)
    * [2.3 xml 属性](#23-xml-属性)
    * [2.4 xml 注释](#24-xml-注释)
    * [2.5 CDATA区](#25-cdata区)
    * [2.6 转义字符](#26-转义字符)
    * [2.7 处理指令](#27-处理指令)
  * [3. xml 约束](#3-xml-约束)
    * [3.1 xml DTD](#31-xml-dtd)
    * [3.2 引用 DTD 约束](#32-引用-dtd-约束)
    * [3.3 DTD约束语法细节](#33-dtd约束语法细节)
    * [3.4 元素定义](#34-元素定义)
    * [3.5 元素定义2](#35-元素定义2)
    * [3.6 属性 attribute](#36-属性-attribute)
    * [3.7 常用属性值类型](#37-常用属性值类型)
      * [3.7.1 属性值类型 -> `ENUMERATED`(枚举)](#371-属性值类型-enumerated枚举)
      * [3.7.2 属性值类型 -> `ID`](#372-属性值类型-id)
      * [3.7.3 属性值类型 -> `ENTITY`(实体)](#373-属性值类型-entity实体)
    * [3.8 自检是否能读懂 DTD 文档](#38-自检是否能读懂-dtd-文档)
    * [3.9 DTD 案例](#39-dtd-案例)
  * [4. XML 编程(CRUD)](#4-xml-编程crud)
    * [4.1 XML 解析技术(DOM 和 SAX)概述及对比](#41-xml-解析技术dom-和-sax概述及对比)
    * [4.2 调整 jvm 内存大小](#42-调整-jvm-内存大小)
    * [4.3 XML 解析开发包(Jaxp(sun), Jdom, dom4j)](#43-xml-解析开发包jaxpsun-jdom-dom4j)
    * [4.4 Jaxp](#44-jaxp)
      * [4.4.1 使用 Jaxp 进行 DOM 解析(读取)](#441-使用-jaxp-进行-dom-解析读取)
      * [4.4.2 使用 Jaxp 进行 DOM 解析(增删改)](#442-使用-jaxp-进行-dom-解析增删改)
    * [4.3 用xml作为持久化设备实现考生成绩管理系统的分析--众多项目为什么设置UI,dao,XmlUtils,domain包的解释](#43-用xml作为持久化设备实现考生成绩管理系统的分析-众多项目为什么设置uidaoxmlutilsdomain包的解释)

<!-- tocstop -->

# day02, 03
xiang
March 7, 2018
## 1. xml语言和作用
XML = Extensible Markup Language = 可扩展标记语言。目前遵循W3C组织于2000年发布的 XML1.0 规范。
xml 作用就是用来描述关系数据(结构化数据)，如下图那个样的数据：
![结构数据](G:\GitHub\BigMass\xiang_方立勋_java_web_30days_notes\day0203\pics\1.png)

所以，xml 可用于保存关系数据，也经常用作软件配置文件，来描述程序模块之间的关系。
如下(内容在下节)。

## 2. xml语法详解
### 2.1 xml 语法声明
#### 2.1.1 encoding 属性
建个config.xml文件，写入如下代码后, 用浏览器打开，以检查xml语法的正确性：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<soft>
  <a>
    <a1>中国</a1>
    <a2></a2>
  </a>

  <b>
    <b1></b1>
    <b2></b2>
  </b>
</soft>
```

中国人面临的编码问题：
xml 声明为 utf-8, 但记事本默认保存为gb2312(os默认编码方式)，所以浏览器无法正确解析(因为你写的xml文档已经声明让ie浏览器用utf-8方式去解析)。
**注意将上面文件另存为encoding为utf-8模式保存**，否则浏览器无法解析。若用eclipse工具不存在这样的问题(细节已自动处理)。

#### 2.1.2 standalone 属性
其值可为 yes 和 no。 yes 代表该 xml 文档是独立的， no 代表是非独立，既依赖于别的文档，用浏览器应该不能直接打开。但ie浏览器不关注这个，依然能打开。

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
```

### 2.2 xml 元素(Element)
**xml 元素 = xml 标签**
写法：
含有标签体： ```<a>www.cnblogs.com/ZhongliangXiang/</a>```
不含标签体： ```<a></a>``` 简写为 ```<a/>```

**必须只有一个根标签。**
**标签中出现的换行和空格**，都会作为标签内容处理(用换行和空格使得文档内容清晰的习惯可能要被迫改变)！下面两段代码意义是不一样的：

```xml
<a>www.cnblogs.com/ZhongliangXiang/</a>
```

```xml
<a>
  www.cnblogs.com/ZhongliangXiang/
</a>
```

### 2.3 xml 属性
一个标签可有多个属性，每个属性都有自己的名字。
XML 技术中，属性所代表的信息也可以用子元素的形式来描述，如:

```xml
<input name="text"></input>
```

```xml
<input>
  <name>text</name>
</input>
```

### 2.4 xml 注释

方式：```<!--注释-->```

**xml声明前不能有注释。**

```xml
这不能写注释
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
```

### 2.5 CDATA区
把不希望 xml 引擎解析的内容放入 CDATA 区，而是当做***原始内容直接输出***：
**做实验时注意encoding问题，把encoding改为"gb2312",或下面文件另存时更改编码方式为utf-8。**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<soft>
  <![CDATA[
  <a>
    <a1>中国</a1>
    <a2></a2>
  </a>
  ]]>

  <b>
    <b1></b1>
    <b2></b2>
  </b>
</soft>
```

### 2.6 转义字符
**原始样式给人看，用转义；**
**给程序看，用 CDATA。**

| 特殊字符 | 替代符号 |
| ------- |:-------:|
| & | ```&amp;``` |
| < | ```&lt;```  |
| > | ```&gt;```  |
| " | ```&quot;```|
| ' | ```&apos;```|

### 2.7 处理指令
简称PI(processing instruction), 用来指挥解析引擎如何解析XML文档内容。
如：xml中使用 ```xml-stylesheet``` 指令，通知xml解析引擎，应用某css文件显示xml文档内容。```<?xml-stylesheet type="text/css" href="1.css"?>```
**我机器ie无法达到效果，而谷歌浏览器可以。**

具体例子：
config1.demo:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/css" href="config1.css"?>

<soft>
  <a>
    <a1 id="a1">中国</a1>
    <a2 id="a2">美国</a2>
  </a>

  <b>
    <b1 id="b1">日本</b1>
    <b2 id="b2">韩国</b2>
  </b>
</soft>
```

再建一个 config1.css 文件，写入：

```css
#a1{
  font-size: 200px;
  color: red;
}

#a2{
  font-size: 150px;
  color: blue;
}

#b1{
  font-size: 100px;
  color: green;
}

#b2{
  font-size: 50px;
  color: pink;
}
```

## 3. xml 约束
xml 技术里，可以编写一个文档来约束另外一个 xml 文档的书写规范，这称为 xml 约束。
为啥需要 xml 约束？
xml 文档通常作为程序配置文件来使用。 框架开发者需告诉该框架使用者如何编写 xml 文档，这就需要 xml 约束，通常是框架开发者写给框架使用者的。
**框架设计者才需写 DTD 来约束使用框架的人。**

常用的约束技术：
* xml DTD(Document Type Definition)
* xml Schema

### 3.1 xml DTD
DTD 文档应使用 utf-8 或 unicode 编码书写。
下图，左侧是 xml 文档，右侧是 dtd 约束文档。dtd 限制了左侧 xml 文档写法。
![dtd快速入门示例](/assets/2.png)

左图(书+)代表“书架”标签里可以有多个“书”标签。`#PCDATA`是 parse character data，可以认为是字符串的意思。
例子：
建立book.dtd文件：

```xml
<!ELEMENT 书架(书+)>
<!ELEMENT 书(书名,作者,售价)>
<!ELEMENT 书名 (#PCDATA)>
<!ELEMENT 作者 (#PCDATA)>
<!ELEMENT 售价 (#PCDATA)>
```

建立book.xml文件：
***其中，`<!DOCTYPE 书架SYSTEM "book.dtd">`用来声明该 xml 文档遵循 book.dtd 约束***。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE 书架 [
  <!ELEMENT 书架(书+)>
  <!ELEMENT 书(书名,作者,售价)>
  <!ELEMENT 书名 (#PCDATA)>
  <!ELEMENT 作者 (#PCDATA)>
  <!ELEMENT 售价 (#PCDATA)>
]>
<书架>
  <书>
    <书名>Java培训教程</书名>
    <作者>张三</作者>
    <售价>39.00</售价>
  </书>

  <书>
    <书名>JavaScript网页开发</书名>
    <作者>李四</作者>
    <售价>28.00</售价>
  </书>
  <!-- <a></a>  ie 无法校验dtd约束，用eclipse则可以-->
</书架>
```

DTD 也可写在 xml 文档内部，如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE 书架 SYSTEM "book.dtd">
<书架>
  <书>
    <书名>Java培训教程</书名>
    <作者>张三</作者>
    <售价>39.00</售价>
  </书>
  <书>
    <书名>JavaScript网页开发</书名>
    <作者>李四</作者>
    <售价>28.00</售价>
  </书>  
</书架>
```

### 3.2 引用 DTD 约束
1. 当引用的文件在本地时，采用如下写法：
`<!DOCTYPE 书架 SYSTEM "book.dtd">`
它表示：书架及子标签将遵循 book.dtd 约束。
2. 当引用的文件是一个公共的文件时，采用下面写法：
`<!DOCTYPE 文档根节点 PUBLIC "DTD名称" "DTD文件的URL">`
例如：
`<!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd">`

### 3.3 DTD约束语法细节
* 元素定义
* 属性定义
* 实体定义

### 3.4 元素定义
元素类型可为元素内容、或类型。
`<!ELEMENT 元素名称 元素类型>`
元素为内容，则用()括起来，如：

```xml
<!ELEMENT 书(书名,作者,售价)>
<!ELEMENT 书名 (#PCDATA)>
```

元素为类型，则直接写，DTD 有如下几种类型：
* EMPTY: 用于定义空元素， 如`<br/>` 或 `<hr/>`；
* ANY: 表元素可为任意类型。

如在 book.dtd 中，将第一句修改为：
`<!ELEMENT 书架 ANY>`
则书架可放任何标签，book.xml 在 eclipse 中也不会报错。

### 3.5 元素定义2
![3](/assets/3.png)

### 3.6 属性 attribute
在 DTD 中为标签定义属性。
在 DTD 中，通过 `ATTLIST`为标签定义属性。
![4](/assets/4.png)

属性定义的设置说明：
* #REQUIRED: 必须设置该属性
* #IMPLIED: 可设置也可不设置
* #FIXED: 固定某个值，且在xml中不能为该属性设置其他值
* 直接使用默认值： 在xml中若不设置该属性，则使用默认值

例子：
在book.dtd中加入如下内容：

```xml
<!ATTLIST 页面作者
  姓名 CDATA #IMPLIED
  年龄 CDATA #IMPLIED
  联系信息 CDATA #REQUIRED
  网站职务 CDATA #FIXED "页面作者"
  个人爱好 CDATA "上网"
>
```

依据上面的 dtd 定义， 有一个新的 demo.xml 文件内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<?DOCTYPE 书架 SYSTEM "book.dtd">
<页面作者 联系信息="China"></页面作者>
```

__“页面作者” 标签上面代码中眼睛看到只有1个属性，但实际上有3个属性，只不过其中2个属性__：网站职务、个人爱好都有默认值了，且网站职务属性值不可由 `xml` 文档更改。

### 3.7 常用属性值类型

* `CDATA`: 表属性值为普通文本字符串；
* `ENUMERATED`
* `ID`
* `ENTITY`(实体)

#### 3.7.1 属性值类型 -> `ENUMERATED`(枚举)
![5](/assets/5.png)
**练习解读上图代码的意思。**
#### 3.7.2 属性值类型 -> `ID`
![6](/assets/6.png)
**练习解读上图代码的意思。**
***注意：我们以后会经常为某些数据配 `ID`，这个 `ID` 的值最好不要以数字开头！***
#### 3.7.3 属性值类型 -> `ENTITY`(实体)
实体用于为一段内容起个别名，类似于变量的概念。
实体分为：
* 引用实体 -- 引用实体在 dtd 中定义，用在 `XML` 文档中；
* 参数实体 -- 定义和使用都在 dtd 文档中。

引用实体：
**引用实体在dtd中定义，用在 `XML` 文档中。**
语法格式：`<!ENTITY 实体名称 "实体内容">`
引用方式：`&实体名称`
举例, 在某个 dtd 文件中有：

```xml
<!ENTITY copyright "I am a programmer">
......
&copyright
```

上述代码中，`copyright`可类比为变量名，`&copyright`则表示该变量的内容`"I am a programmer"`。
例子：
在book.dtd文件中加入`<!ENTITY bookname "javaweb开发">`，同时在 book.xml 中，加入`<书名>&bookname;</书名>`。我们用浏览器打开 book.xml，看到 `&bookname`会被替换成`javaweb开发`。
> 注：这个实验，我没做成功，好像现在的浏览器已经不支持引用实体了。

参数实体：
**定义和使用都在 dtd 文档中，用处是简化书写，做到代码重用。**

![7](/assets/7.png)

### 3.8 自检是否能读懂 DTD 文档
![8](/assets/8.png)
试着读上述图片所示的 struts2 的DTD文档。

### 3.9 DTD 案例
目的是验证自己是否能读懂 dtd 约束文档。
dtd文件来自：http://www.w3school.com.cn/dtd/dtd_examples.asp
且把那个 CATALOG 的 dtd 文档写入 下面新建的 CATALOG.xml 文件前面，如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE CATALOG [

<!ENTITY AUTHOR "John Doe">
<!ENTITY COMPANY "JD Power Tools, Inc.">
<!ENTITY EMAIL "jd@jd-tools.com">

<!ELEMENT CATALOG (PRODUCT+)>

<!ELEMENT PRODUCT
(SPECIFICATIONS+,OPTIONS?,PRICE+,NOTES?)>
<!ATTLIST PRODUCT
NAME CDATA #IMPLIED
CATEGORY (HandTool|Table|Shop-Professional) "HandTool"
PARTNUM CDATA #IMPLIED
PLANT (Pittsburgh|Milwaukee|Chicago) "Chicago"
INVENTORY (InStock|Backordered|Discontinued) "InStock">

<!ELEMENT SPECIFICATIONS (#PCDATA)>
<!ATTLIST SPECIFICATIONS
WEIGHT CDATA #IMPLIED
POWER CDATA #IMPLIED>

<!ELEMENT OPTIONS (#PCDATA)>
<!ATTLIST OPTIONS
FINISH (Metal|Polished|Matte) "Matte"
ADAPTER (Included|Optional|NotApplicable) "Included"
CASE (HardShell|Soft|NotApplicable) "HardShell">

<!ELEMENT PRICE (#PCDATA)>
<!ATTLIST PRICE
MSRP CDATA #IMPLIED
WHOLESALE CDATA #IMPLIED
STREET CDATA #IMPLIED
SHIPPING CDATA #IMPLIED>

<!ELEMENT NOTES (#PCDATA)>
]>
<!-- 下面是根据 dtd 文档写的 xml 文档 -->
<CATALOG>
	<PRODUCT>
		<SPECIFICATIONS>aaaa</SPECIFICATIONS>
		<OPTIONS>bbbb</OPTIONS>
		<PRICE>cccc</PRICE>
		<NOTES>dddd</NOTES>
	</PRODUCT>
</CATALOG>
```

上面代码里的 `<PRICE>cccc</PRICE>`， 表明 dtd 约束的劣势(dtd 会逐渐淘汰)，即 dtd 无法详细约束数据类型(PRICE 应该是数字，但 dtd 无法提供这样的约束，这就需要另一种约束： Schema 约束。下节讲。)。

## 4. XML 编程(CRUD)
CRUD = Create, Read, Update, Delete
XML 编程：**就是在XML文档里增、删、改、查数据**，简称 CRUD。

### 4.1 XML 解析技术(DOM 和 SAX)概述及对比
xml 解析方式有两种：
* dom(Document Object Model) -- wec推荐的解析xml的方式；
* sax(Simple API for XML) -- xml 社区事实标准，所有解析器都支持它。

关于 dom 和 sax 这两种 xml 解析方式的解释，如下图：
![9](/assets/9.png)

关于 dom 解析方式:
**优点：方便地支持 cud，r 当然也没问题；缺点：需将整个 xml 整个文档所述内容以各种对象(如element对象，text对象，attribute对象)的形式存储在内存中，即不适合处理大 xml 文档，耗费内存多**。

关于 sax 解析方式:
sax 以逐行读取的方式处理 xml 文档。**优点：内存占用极少；缺点：不能 cud，只能 r。**

### 4.2 调整 jvm 内存大小
动机：运行大文件或内容，超出 jvm 默认占用内存大小。
方法：
Eclipse 中，执行程序是选择 Run Configuration -> Arguments -> VM arguments 中填写`-Xmx1024m`，意为调整为1024m内存, 点 Run 运行即可。

### 4.3 XML 解析开发包(Jaxp(sun), Jdom, dom4j)
XML 解析包有 Jaxp(sun), Jdom, dom4j。性能上 dom4j 最优， Jaxp(sun) 最差但却是sun开发的，涉及到标准一类的事情。因此，我们要学习 dom4j 和 Jaxp(sun), 不学习 Jdom。

### 4.4 Jaxp
Jaxp 开发包是J2SE的一部分，**创建工程后不需额外导入**。它由`javax.xml`,`org.w3c.dom`和`org.xml.sax`包及其子包组成。
**在`javax.xml.parsers`包中，定义了几个工厂类，程序员调用这些工厂类，可以得到 xml 文档的 DOM 或 SAX 的解析器，从而实现对xml文档的解析。**

#### 4.4.1 使用 Jaxp 进行 DOM 解析(读取)
就是用 `javax.xml.parsers` 包中的 `DocumentBuilderFactory` 创建 DOM 模式的解析器对象。完整过程例子如下：
材料准备-> 在项目的 src 目录下创建`book.xml`文档，内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<书架>
  <书>
    <书名 name="xxxx">Java培训教程</书名>
    <作者>张三</作者>
    <售价>39.00</售价>
  </书>
  <书>
    <书名>JavaScript网页开发</书名>
    <作者>李四</作者>
    <售价>28.00</售价>
  </书>  
</书架>
```

建立Demo.java:
重点：4步
1. 建工厂
2. 获取dom解析器
3. 获取document
4. 用之

需求1：读取 `<书名>JavaScript网页开发</书名>` 中书名标签的值

```java
// 使用dom方式对xml文档进行crud
public class Demo {
 @Test
 public void read1() throws Exception {

  //1.创建工厂
  DocumentBuilderFactory factory =
    DocumentBuilderFactory.newInstance();

  //2.得到 dom 解析器
  DocumentBuilder builder = factory.newDocumentBuilder();

  //3.解析 xml 文档，得到代表文档的 document
  Document document = builder.parse("src/book.xml");

  //4.使用该 document 做事情，举例如下：  
  NodeList list = document.getElementsByTagName("书名");
  Node node = list.item(1);
  String content = node.getTextContent();
  System.out.println(content);
 }
}
```

输出结果：

```
JavaScript网页开发
```
==注意：dom解析下，xml 文档的每一个组成部分都会用一个对象表示，例如标签用Element, 属性用Attr,但不管什么对象，都是Node的子类，所以开发时可把获取的任意节点当作Node对待。==

需求2：遍历 xml 文档中所有标签(Element)

```java
// 需求：得到 xml 文档中所有标签
@Test
public void read2() throws Exception {

 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
 DocumentBuilder builder = factory.newDocumentBuilder();
 Document document = builder.parse("src/book.xml");

 // 得到根节点
 Node root = document.getElementsByTagName("书架").item(0);
 list(root); // 递归找root下的孩子
}

private void list(Node node) {
 if (node instanceof Element)
  System.out.println(node.getNodeName());

 NodeList children = node.getChildNodes();
 for (int i = 0; i < children.getLength(); i++) {
  Node child = children.item(i);
  list(child);
 }
}
```

输出结果：

```
书架
书
书名
作者
售价
书
书名
作者
售价
```

需求3：获取`<书名 name="xxxx">Java程序设计</书名>`中属性`name`的值

```java
// 需求：获得 标签的属性值
@Test
public void read3() throws Exception {
 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
 DocumentBuilder builder = factory.newDocumentBuilder();
 Document document = builder.parse("src/book.xml");

 // node 强转成 Element
 Element bookname = (Element) document.getElementsByTagName("书名")
   .item(0);
 String value = bookname.getAttribute("name");
 System.out.println(value);
}
```

#### 4.4.2 使用 Jaxp 进行 DOM 解析(增删改)
本节基于`book.xml`文档做了些示例代码，`book.xml`文档如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<书架>
	<书>
		<书名>Java培训教程</书名>
		<作者>张三</作者>
		<售价>39.00</售价>
	</书>
	<书>
		<书名>JavaScript网页开发</书名>
		<作者>李四</作者>
		<售价>28.00</售价>
	</书>
</书架>
```

增删改花10多分钟学习下下面代码就行了：

```java
// 向 xml 文档添加节点：<售价>59.00元</售价>
	@Test
	public void add1() throws Exception {
    // 获取 document 对象
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		Document document = builder.parse("src/book.xml");

		// 1.创建节点
		Element price = document.createElement("售价");
		price.setTextContent("59.00元");

		// 2.把创建的节点挂在第1本书上
		Element book = (Element) document.getElementsByTagName("书").item(0);
		book.appendChild(price);

		// 3.把更新后的内存对象 document 写回到 xml 文档
		TransformerFactory tf_factory = TransformerFactory.newInstance(); // 建transformer工厂
		Transformer tf = tf_factory.newTransformer(); // 获得转换器
		tf.transform(new DOMSource(document), new StreamResult(
				new FileOutputStream("src/book.xml"))); // 注意 源 和 目地 的写法
	}

	// 向 xml 文档指定位置添加节点：<售价>59.00元</售价>
	@Test
	public void add2() throws Exception {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		Document document = builder.parse("src/book.xml");

		// 1.创建节点
		Element price = document.createElement("售价");
		price.setTextContent("59.00元");

		// 2.获得参考节点
		Element ref = (Element) document.getElementsByTagName("售价").item(0);

		// 3.获得欲插入崽的节点
		Element book = (Element) document.getElementsByTagName("书").item(0);

		// 4.插入参考节点的前面
		book.insertBefore(price, ref);

		// 5.更新 xml 文档
		TransformerFactory tf_factory = TransformerFactory.newInstance();
		Transformer tf = tf_factory.newTransformer();
		tf.transform(new DOMSource(document), new StreamResult(
				new FileOutputStream("src/book.xml")));
	}

	// 向 xml文档指定标签添加属性：<书名>Java培训教程</书名> 添加name="xxxx"属性
	@Test
	public void addArr() throws Exception {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		Document document = builder.parse("src/book.xml");

		// 1.获得节点
		Element book_name = (Element) document.getElementsByTagName("书名").item(
				0);

		// 2.添加属性
		book_name.setAttribute("name", "xxxx");

		// 3.更新 xml 文档
		TransformerFactory tf_factory = TransformerFactory.newInstance();
		Transformer tf = tf_factory.newTransformer();
		tf.transform(new DOMSource(document), new StreamResult(
				new FileOutputStream("src/book.xml")));
	}

	// 删除指定节点：<售价>59.00</售价>
	@Test
	public void delete() throws Exception {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		Document document = builder.parse("src/book.xml");

		// 1.获得要删除的节点
		Element price = (Element) document.getElementsByTagName("售价").item(0);

		// 2.通过儿子找爸爸
		Element book = (Element) price.getParentNode();

		// 3.调用爸爸删崽
		book.removeChild(price);

		// 4.更新 xml 文档
		TransformerFactory tf_factory = TransformerFactory.newInstance();
		Transformer tf = tf_factory.newTransformer();
		tf.transform(new DOMSource(document), new StreamResult(
				new FileOutputStream("src/book.xml")));
	}

	// 更新售价：<售价>59.00</售价> -> <售价>109.00</售价>
	@Test
	public void update() throws Exception {
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		Document document = builder.parse("src/book.xml");

		// 1.获得要更新的节点
		Element price = (Element) document.getElementsByTagName("售价").item(0);

		// 2.更新价格
		price.setTextContent("109.00");

		// 3.更新 xml 文档
		TransformerFactory tf_factory = TransformerFactory.newInstance();
		Transformer tf = tf_factory.newTransformer();
		tf.transform(new DOMSource(document), new StreamResult(
				new FileOutputStream("src/book.xml")));
	}
```

### 4.3 用xml作为持久化设备实现考生成绩管理系统的分析--众多项目为什么设置UI,dao,XmlUtils,domain包的解释

![10](/assets/10.png)
